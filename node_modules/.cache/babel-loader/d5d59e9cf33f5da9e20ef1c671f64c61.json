{"ast":null,"code":"import { geoDelaunay } from \"./delaunay.js\";\nimport { geoInterpolate } from \"d3-geo\";\nimport { tricontour } from \"d3-tricontour\";\nexport function geoContour() {\n  let v;\n  const contour = tricontour().triangulate((data, x, y) => {\n    v = geoDelaunay(data.map(d => [x(d), y(d)]));\n    return v.delaunay;\n  }).pointInterpolate((i, j, a) => {\n    const {\n      points,\n      projection\n    } = v.delaunay;\n    const A = projection.invert([points[2 * i], points[2 * i + 1]]),\n          B = projection.invert([points[2 * j], points[2 * j + 1]]);\n    return geoInterpolate(A, B)(a);\n  }).ringsort(rings => {\n    // tricky thing: in isobands this function is called twice,\n    // we want to reverse the polygons’s winding order only in tricontour()\n    // not in isoband()\n    if (rings.length && !rings[0].reversed) {\n      rings.forEach(ring => ring.reverse());\n      rings[0].reversed = true;\n    }\n\n    return [rings];\n  });\n  return contour;\n}","map":{"version":3,"names":["geoDelaunay","geoInterpolate","tricontour","geoContour","v","contour","triangulate","data","x","y","map","d","delaunay","pointInterpolate","i","j","a","points","projection","A","invert","B","ringsort","rings","length","reversed","forEach","ring","reverse"],"sources":["/Users/ludvigbergsaker/Documents/Notify/notify_custom/notify_custom/node_modules/d3-geo-voronoi/src/contour.js"],"sourcesContent":["import {geoDelaunay} from \"./delaunay.js\";\nimport {geoInterpolate} from \"d3-geo\";\nimport {tricontour} from \"d3-tricontour\";\n\nexport function geoContour() {\n  let v;\n  const contour = tricontour()\n    .triangulate((data, x, y) => {\n      v = geoDelaunay(data.map(d => [x(d), y(d)]));\n      return v.delaunay;\n    })\n    .pointInterpolate((i, j, a) => {\n      const { points, projection } = v.delaunay;\n      const A = projection.invert([points[2 * i], points[2 * i + 1]]),\n         B = projection.invert([points[2 * j], points[2 * j + 1]]);\n      return geoInterpolate(A, B)(a);\n    })\n    .ringsort(rings => {\n      // tricky thing: in isobands this function is called twice,\n      // we want to reverse the polygons’s winding order only in tricontour()\n      // not in isoband()\n      if (rings.length && !rings[0].reversed) {\n        rings.forEach(ring => ring.reverse());\n        rings[0].reversed = true;\n      }\n      return [rings];\n    });\n\n  return contour;\n}\n"],"mappings":"AAAA,SAAQA,WAAR,QAA0B,eAA1B;AACA,SAAQC,cAAR,QAA6B,QAA7B;AACA,SAAQC,UAAR,QAAyB,eAAzB;AAEA,OAAO,SAASC,UAAT,GAAsB;EAC3B,IAAIC,CAAJ;EACA,MAAMC,OAAO,GAAGH,UAAU,GACvBI,WADa,CACD,CAACC,IAAD,EAAOC,CAAP,EAAUC,CAAV,KAAgB;IAC3BL,CAAC,GAAGJ,WAAW,CAACO,IAAI,CAACG,GAAL,CAASC,CAAC,IAAI,CAACH,CAAC,CAACG,CAAD,CAAF,EAAOF,CAAC,CAACE,CAAD,CAAR,CAAd,CAAD,CAAf;IACA,OAAOP,CAAC,CAACQ,QAAT;EACD,CAJa,EAKbC,gBALa,CAKI,CAACC,CAAD,EAAIC,CAAJ,EAAOC,CAAP,KAAa;IAC7B,MAAM;MAAEC,MAAF;MAAUC;IAAV,IAAyBd,CAAC,CAACQ,QAAjC;IACA,MAAMO,CAAC,GAAGD,UAAU,CAACE,MAAX,CAAkB,CAACH,MAAM,CAAC,IAAIH,CAAL,CAAP,EAAgBG,MAAM,CAAC,IAAIH,CAAJ,GAAQ,CAAT,CAAtB,CAAlB,CAAV;IAAA,MACGO,CAAC,GAAGH,UAAU,CAACE,MAAX,CAAkB,CAACH,MAAM,CAAC,IAAIF,CAAL,CAAP,EAAgBE,MAAM,CAAC,IAAIF,CAAJ,GAAQ,CAAT,CAAtB,CAAlB,CADP;IAEA,OAAOd,cAAc,CAACkB,CAAD,EAAIE,CAAJ,CAAd,CAAqBL,CAArB,CAAP;EACD,CAVa,EAWbM,QAXa,CAWJC,KAAK,IAAI;IACjB;IACA;IACA;IACA,IAAIA,KAAK,CAACC,MAAN,IAAgB,CAACD,KAAK,CAAC,CAAD,CAAL,CAASE,QAA9B,EAAwC;MACtCF,KAAK,CAACG,OAAN,CAAcC,IAAI,IAAIA,IAAI,CAACC,OAAL,EAAtB;MACAL,KAAK,CAAC,CAAD,CAAL,CAASE,QAAT,GAAoB,IAApB;IACD;;IACD,OAAO,CAACF,KAAD,CAAP;EACD,CApBa,CAAhB;EAsBA,OAAOlB,OAAP;AACD"},"metadata":{},"sourceType":"module"}