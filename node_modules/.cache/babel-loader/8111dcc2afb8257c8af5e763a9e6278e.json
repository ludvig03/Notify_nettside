{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Float32BufferAttribute, InstancedBufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, MathUtils, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector3 } from 'three';\n\nfunction computeTangents() {\n  throw new Error('BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.');\n}\n\nfunction computeMikkTSpaceTangents(geometry, MikkTSpace) {\n  let negateSign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (!MikkTSpace || !MikkTSpace.isReady) {\n    throw new Error('BufferGeometryUtils: Initialized MikkTSpace library required.');\n  }\n\n  if (!geometry.hasAttribute('position') || !geometry.hasAttribute('normal') || !geometry.hasAttribute('uv')) {\n    throw new Error('BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.');\n  }\n\n  function getAttributeArray(attribute) {\n    if (attribute.normalized || attribute.isInterleavedBufferAttribute) {\n      const srcArray = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\n      const dstArray = new Float32Array(attribute.getCount() * attribute.itemSize);\n\n      for (let i = 0, j = 0; i < attribute.getCount(); i++) {\n        dstArray[j++] = MathUtils.denormalize(attribute.getX(i), srcArray);\n        dstArray[j++] = MathUtils.denormalize(attribute.getY(i), srcArray);\n\n        if (attribute.itemSize > 2) {\n          dstArray[j++] = MathUtils.denormalize(attribute.getZ(i), srcArray);\n        }\n      }\n\n      return dstArray;\n    }\n\n    if (attribute.array instanceof Float32Array) {\n      return attribute.array;\n    }\n\n    return new Float32Array(attribute.array);\n  } // MikkTSpace algorithm requires non-indexed input.\n\n\n  const _geometry = geometry.index ? geometry.toNonIndexed() : geometry; // Compute vertex tangents.\n\n\n  const tangents = MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position), getAttributeArray(_geometry.attributes.normal), getAttributeArray(_geometry.attributes.uv)); // Texture coordinate convention of glTF differs from the apparent\n  // default of the MikkTSpace library; .w component must be flipped.\n\n  if (negateSign) {\n    for (let i = 3; i < tangents.length; i += 4) {\n      tangents[i] *= -1;\n    }\n  } //\n\n\n  _geometry.setAttribute('tangent', new BufferAttribute(tangents, 4));\n\n  if (geometry !== _geometry) {\n    geometry.copy(_geometry);\n  }\n\n  return geometry;\n}\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\n\n\nfunction mergeBufferGeometries(geometries) {\n  let useGroups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n\n  for (let i = 0; i < geometries.length; ++i) {\n    const geometry = geometries[i];\n    let attributesCount = 0; // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geometry.index !== null)) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n      return null;\n    } // gather attributes, exit early if they're different\n\n\n    for (const name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n\n      if (attributes[name] === undefined) attributes[name] = [];\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    } // ensure geometries have the same number of attributes\n\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n      return null;\n    } // gather morph attributes, exit early if they're different\n\n\n    if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n      return null;\n    }\n\n    for (const name in geometry.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n        return null;\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n      morphAttributes[name].push(geometry.morphAttributes[name]);\n    } // gather .userData\n\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geometry.userData);\n\n    if (useGroups) {\n      let count;\n\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n        return null;\n      }\n\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  } // merge indices\n\n\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n\n    for (let i = 0; i < geometries.length; ++i) {\n      const index = geometries[i].index;\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n\n      indexOffset += geometries[i].attributes.position.count;\n    }\n\n    mergedGeometry.setIndex(mergedIndex);\n  } // merge attributes\n\n\n  for (const name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n\n    if (!mergedAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n      return null;\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  } // merge morph attributes\n\n\n  for (const name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n\n      if (!mergedMorphAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n        return null;\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n\n  return mergedGeometry;\n}\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\n\n\nfunction mergeBufferAttributes(attributes) {\n  let TypedArray;\n  let itemSize;\n  let normalized;\n  let arrayLength = 0;\n\n  for (let i = 0; i < attributes.length; ++i) {\n    const attribute = attributes[i];\n\n    if (attribute.isInterleavedBufferAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');\n      return null;\n    }\n\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n      return null;\n    }\n\n    if (itemSize === undefined) itemSize = attribute.itemSize;\n\n    if (itemSize !== attribute.itemSize) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n      return null;\n    }\n\n    if (normalized === undefined) normalized = attribute.normalized;\n\n    if (normalized !== attribute.normalized) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n      return null;\n    }\n\n    arrayLength += attribute.array.length;\n  }\n\n  const array = new TypedArray(arrayLength);\n  let offset = 0;\n\n  for (let i = 0; i < attributes.length; ++i) {\n    array.set(attributes[i].array, offset);\n    offset += attributes[i].array.length;\n  }\n\n  return new BufferAttribute(array, itemSize, normalized);\n}\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\n\n\nfunction interleaveAttributes(attributes) {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray;\n  let arrayLength = 0;\n  let stride = 0; // calculate the the length and type of the interleavedBuffer\n\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved');\n      return null;\n    }\n\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  } // Create the set of buffer attributes\n\n\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\n  const setters = ['setX', 'setY', 'setZ', 'setW'];\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        iba[setters[k]](c, attribute[getters[k]](c));\n      }\n    }\n  }\n\n  return res;\n} // returns a new, non-interleaved version of the provided attribute\n\n\nexport function deinterleaveAttribute(attribute) {\n  const cons = attribute.data.array.constructor;\n  const count = attribute.count;\n  const itemSize = attribute.itemSize;\n  const normalized = attribute.normalized;\n  const array = new cons(count * itemSize);\n  let newAttribute;\n\n  if (attribute.isInstancedInterleavedBufferAttribute) {\n    newAttribute = new InstancedBufferAttribute(array, itemSize, normalized, attribute.meshPerAttribute);\n  } else {\n    newAttribute = new BufferAttribute(array, itemSize, normalized);\n  }\n\n  for (let i = 0; i < count; i++) {\n    newAttribute.setX(i, attribute.getX(i));\n\n    if (itemSize >= 2) {\n      newAttribute.setY(i, attribute.getY(i));\n    }\n\n    if (itemSize >= 3) {\n      newAttribute.setZ(i, attribute.getZ(i));\n    }\n\n    if (itemSize >= 4) {\n      newAttribute.setW(i, attribute.getW(i));\n    }\n  }\n\n  return newAttribute;\n} // deinterleaves all attributes on the geometry\n\nexport function deinterleaveGeometry(geometry) {\n  const attributes = geometry.attributes;\n  const morphTargets = geometry.morphTargets;\n  const attrMap = new Map();\n\n  for (const key in attributes) {\n    const attr = attributes[key];\n\n    if (attr.isInterleavedBufferAttribute) {\n      if (!attrMap.has(attr)) {\n        attrMap.set(attr, deinterleaveAttribute(attr));\n      }\n\n      attributes[key] = attrMap.get(attr);\n    }\n  }\n\n  for (const key in morphTargets) {\n    const attr = morphTargets[key];\n\n    if (attr.isInterleavedBufferAttribute) {\n      if (!attrMap.has(attr)) {\n        attrMap.set(attr, deinterleaveAttribute(attr));\n      }\n\n      morphTargets[key] = attrMap.get(attr);\n    }\n  }\n}\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\n\nfunction estimateBytesUsed(geometry) {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0;\n\n  for (const name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\n\n\nfunction mergeVertices(geometry) {\n  let tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n  tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute('position');\n  const vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n  let nextIndex = 0; // attributes and new attribute arrays\n\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\n\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(() => []);\n    }\n  } // convert the error tolerance to an amount of decimal places to truncate to\n\n\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'\n\n    let hash = '';\n\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    } // Add another reference to the vertex if it's already\n    // used by another index\n\n\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  } // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n\n\n  const result = geometry.clone();\n\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute); // Update the attribute arrays\n\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  } // indices\n\n\n  result.setIndex(newIndices);\n  return result;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry>}\n */\n\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n    return geometry;\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex(); // generate index if not present\n\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute('position');\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    } //\n\n\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n\n    if (drawMode === TriangleFanDrawMode) {\n      // gl.TRIANGLE_FAN\n      for (let i = 1; i <= numberOfTriangles; i++) {\n        newIndices.push(index.getX(0));\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n      }\n    } else {\n      // gl.TRIANGLE_STRIP\n      for (let i = 0; i < numberOfTriangles; i++) {\n        if (i % 2 === 0) {\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i + 2));\n        } else {\n          newIndices.push(index.getX(i + 2));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i));\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    } // build final geometry\n\n\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n}\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\n\n\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n    return null;\n  }\n\n  const _vA = new Vector3();\n\n  const _vB = new Vector3();\n\n  const _vC = new Vector3();\n\n  const _tempA = new Vector3();\n\n  const _tempB = new Vector3();\n\n  const _tempC = new Vector3();\n\n  const _morphA = new Vector3();\n\n  const _morphB = new Vector3();\n\n  const _morphC = new Vector3();\n\n  function _calculateMorphedAttributeData(object, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a);\n\n    _vB.fromBufferAttribute(attribute, b);\n\n    _vC.fromBufferAttribute(attribute, c);\n\n    const morphInfluences = object.morphTargetInfluences;\n\n    if (morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n\n      _morphB.set(0, 0, 0);\n\n      _morphC.set(0, 0, 0);\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i];\n        const morph = morphAttribute[i];\n        if (influence === 0) continue;\n\n        _tempA.fromBufferAttribute(morph, a);\n\n        _tempB.fromBufferAttribute(morph, b);\n\n        _tempC.fromBufferAttribute(morph, c);\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n\n          _morphB.addScaledVector(_tempB, influence);\n\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n\n      _vA.add(_morphA);\n\n      _vB.add(_morphB);\n\n      _vC.add(_morphC);\n    }\n\n    if (object.isSkinnedMesh) {\n      object.boneTransform(a, _vA);\n      object.boneTransform(b, _vB);\n      object.boneTransform(c, _vC);\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\n  }\n\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n\n  if (index !== null) {\n    // indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n\n          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n\n        _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else {\n    // non-indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n\n          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n\n        _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n}\n\nfunction mergeGroups(geometry) {\n  if (geometry.groups.length === 0) {\n    console.warn('THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.');\n    return geometry;\n  }\n\n  let groups = geometry.groups; // sort groups by material index\n\n  groups = groups.sort((a, b) => {\n    if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;\n    return a.start - b.start;\n  }); // create index for non-indexed geometries\n\n  if (geometry.getIndex() === null) {\n    const positionAttribute = geometry.getAttribute('position');\n    const indices = [];\n\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      indices.push(i, i + 1, i + 2);\n    }\n\n    geometry.setIndex(indices);\n  } // sort index\n\n\n  const index = geometry.getIndex();\n  const newIndices = [];\n\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    const groupStart = group.start;\n    const groupLength = groupStart + group.count;\n\n    for (let j = groupStart; j < groupLength; j++) {\n      newIndices.push(index.getX(j));\n    }\n  }\n\n  geometry.dispose(); // Required to force buffer recreation\n\n  geometry.setIndex(newIndices); // update groups indices\n\n  let start = 0;\n\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    group.start = start;\n    start += group.count;\n  } // merge groups\n\n\n  let currentGroup = groups[0];\n  geometry.groups = [currentGroup];\n\n  for (let i = 1; i < groups.length; i++) {\n    const group = groups[i];\n\n    if (currentGroup.materialIndex === group.materialIndex) {\n      currentGroup.count += group.count;\n    } else {\n      currentGroup = group;\n      geometry.groups.push(currentGroup);\n    }\n  }\n\n  return geometry;\n}\n\nexport { computeTangents, computeMikkTSpaceTangents, mergeBufferGeometries, mergeBufferAttributes, interleaveAttributes, estimateBytesUsed, mergeVertices, toTrianglesDrawMode, computeMorphedAttributes, mergeGroups };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Float32BufferAttribute","InstancedBufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","MathUtils","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","Vector3","computeTangents","Error","computeMikkTSpaceTangents","geometry","MikkTSpace","negateSign","isReady","hasAttribute","getAttributeArray","attribute","normalized","isInterleavedBufferAttribute","srcArray","data","array","dstArray","Float32Array","getCount","itemSize","i","j","denormalize","getX","getY","getZ","_geometry","index","toNonIndexed","tangents","generateTangents","attributes","position","normal","uv","length","setAttribute","copy","mergeBufferGeometries","geometries","useGroups","isIndexed","attributesUsed","Set","Object","keys","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","attributesCount","console","error","name","has","undefined","push","size","userData","mergedUserData","count","addGroup","indexOffset","mergedIndex","setIndex","mergedAttribute","mergeBufferAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","arrayLength","constructor","set","interleaveAttributes","stride","l","interleavedBuffer","res","getters","setters","iba","c","k","deinterleaveAttribute","cons","newAttribute","isInstancedInterleavedBufferAttribute","meshPerAttribute","setX","setY","setZ","setW","getW","deinterleaveGeometry","morphTargets","attrMap","Map","key","attr","get","estimateBytesUsed","mem","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","a","b","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","il","influence","morph","addScaledVector","sub","add","isSkinnedMesh","boneTransform","x","y","z","material","positionAttribute","morphPosition","normalAttribute","morphNormal","groups","drawRange","jl","group","start","end","modifiedPosition","modifiedNormal","isArray","min","morphedPositionAttribute","morphedNormalAttribute","mergeGroups","sort","materialIndex","groupStart","groupLength","dispose","currentGroup"],"sources":["/Users/ludvigbergsaker/Documents/Notify/notify_custom/notify_custom/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tMathUtils,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeTangents() {\n\n\tthrow new Error( 'BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.' );\n\n}\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst srcArray = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\n\t\t\tconst dstArray = new Float32Array( attribute.getCount() * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.getCount(); i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getX( i ), srcArray );\n\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getY( i ), srcArray );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getZ( i ), srcArray );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\t// gather .userData\n\n\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeBufferAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\treturn new BufferAttribute( array, itemSize, normalized );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst attrArrays = {};\n\tconst morphAttrsArrays = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t// initialize the arrays\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\n\t\tattrArrays[ name ] = [];\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the attribute arrays\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = attrArrays[ name ];\n\t\t\t\tconst newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// Generate typed arrays from new attribute arrays and update\n\t// the attributeBuffers\n\tconst result = geometry.clone();\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst oldAttribute = geometry.getAttribute( name );\n\n\t\tconst buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\tconst attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\tresult.setAttribute( name, attribute );\n\n\t\t// Update the attribute arrays\n\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\tfor ( let j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\tconst oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\tconst buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\tconst morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry>}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\treturn null;\n\n\t}\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.boneTransform( a, _vA );\n\t\t\tobject.boneTransform( b, _vB );\n\t\t\tobject.boneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\nexport {\n\tcomputeTangents,\n\tcomputeMikkTSpaceTangents,\n\tmergeBufferGeometries,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}