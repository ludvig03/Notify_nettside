{"ast":null,"code":"import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Vector2, Line3, MathUtils, Matrix4, Mesh, Vector4 } from 'three';\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n}; // support multiple method names for backwards threejs compatibility\n\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _box$1 = new THREE$2.Box3();\n\nconst _vector = new THREE$2.Vector3();\n\nclass LineSegmentsGeometry extends THREE$2.InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.type = 'LineSegmentsGeometry';\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this[setAttributeFn$1]('position', new THREE$2.Float32BufferAttribute(positions, 3));\n    this[setAttributeFn$1]('uv', new THREE$2.Float32BufferAttribute(uvs, 2));\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  setPositions(array) {\n    let lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    const instanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn$1]('instanceStart', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn$1]('instanceEnd', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n\n  setColors(array) {\n    let colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    const instanceColorBuffer = new THREE$2.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn$1]('instanceColorStart', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn$1]('instanceColorEnd', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new THREE$2.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new THREE$2.Box3();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start);\n\n      _box$1.setFromBufferAttribute(end);\n\n      this.boundingBox.union(_box$1);\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new THREE$2.Sphere();\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n\n        _vector.fromBufferAttribute(end, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n      }\n    }\n  }\n\n  toJSON() {// todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n}\n\nLineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  worldUnits: {\n    value: 1\n  },\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new THREE$1.Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  } // todo FIX - maybe change to totalSize\n\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\tworldStart = start.xyz;\n\t\t\tworldEnd = end.xyz;\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segements overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends THREE$1.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n      uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n      vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n      fragmentShader: THREE$1.ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      worldUnits: {\n        enumerable: true,\n        get: function () {\n          return 'WORLD_UNITS' in this.defines;\n        },\n        set: function (value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = '';\n          } else {\n            delete this.defines.WORLD_UNITS;\n          }\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n\n        set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value === true) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value === true) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nLineMaterial.prototype.isLineMaterial = true;\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4\n};\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _start = new THREE.Vector3();\n\nconst _end = new THREE.Vector3();\n\nconst _start4 = new THREE.Vector4();\n\nconst _end4 = new THREE.Vector4();\n\nconst _ssOrigin = new THREE.Vector4();\n\nconst _ssOrigin3 = new THREE.Vector3();\n\nconst _mvMatrix = new THREE.Matrix4();\n\nconst _line = new THREE.Line3();\n\nconst _closestPoint = new THREE.Vector3();\n\nconst _box = new THREE.Box3();\n\nconst _sphere = new THREE.Sphere();\n\nconst _clipToWorldVector = new THREE.Vector4();\n\nclass LineSegments2 extends THREE.Mesh {\n  constructor() {\n    let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new LineSegmentsGeometry();\n    let material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineMaterial({\n      color: Math.random() * 0xffffff\n    });\n    super(geometry, material);\n    this.type = 'LineSegments2';\n  } // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry[setAttributeFn]('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry[setAttributeFn]('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    const ray = raycaster.ray;\n    const camera = raycaster.camera;\n    const projectionMatrix = camera.projectionMatrix;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    const resolution = material.resolution;\n    const lineWidth = material.linewidth + threshold;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n    const near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\n    // width in clip space\n\n    const ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\n    // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n\n    const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _sphere.radius += sphereMargin;\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) {\n      return;\n    } //\n    // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n\n    const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _box.max.x += boxMargin;\n    _box.max.y += boxMargin;\n    _box.max.z += boxMargin;\n    _box.min.x -= boxMargin;\n    _box.min.y -= boxMargin;\n    _box.min.z -= boxMargin;\n\n    if (raycaster.ray.intersectsBox(_box) === false) {\n      return;\n    } //\n    // pick a point 1 unit out along the ray to avoid the ray origin\n    // sitting at the camera origin which will cause \"w\" to be 0 when\n    // applying the projection matrix.\n\n\n    ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n    _ssOrigin.w = 1;\n\n    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n    _ssOrigin.applyMatrix4(projectionMatrix);\n\n    _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n    _ssOrigin.x *= resolution.x / 2;\n    _ssOrigin.y *= resolution.y / 2;\n    _ssOrigin.z = 0;\n\n    _ssOrigin3.copy(_ssOrigin);\n\n    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n    for (let i = 0, l = instanceStart.count; i < l; i++) {\n      _start4.fromBufferAttribute(instanceStart, i);\n\n      _end4.fromBufferAttribute(instanceEnd, i);\n\n      _start4.w = 1;\n      _end4.w = 1; // camera space\n\n      _start4.applyMatrix4(_mvMatrix);\n\n      _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n      var isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n      if (isBehindCameraNear) {\n        continue;\n      } // trim the segment if it extends behind camera near\n\n\n      if (_start4.z > near) {\n        const deltaDist = _start4.z - _end4.z;\n        const t = (_start4.z - near) / deltaDist;\n\n        _start4.lerp(_end4, t);\n      } else if (_end4.z > near) {\n        const deltaDist = _end4.z - _start4.z;\n        const t = (_end4.z - near) / deltaDist;\n\n        _end4.lerp(_start4, t);\n      } // clip space\n\n\n      _start4.applyMatrix4(projectionMatrix);\n\n      _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n      _start4.multiplyScalar(1 / _start4.w);\n\n      _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n      _start4.x *= resolution.x / 2;\n      _start4.y *= resolution.y / 2;\n      _end4.x *= resolution.x / 2;\n      _end4.y *= resolution.y / 2; // create 2d segment\n\n      _line.start.copy(_start4);\n\n      _line.start.z = 0;\n\n      _line.end.copy(_end4);\n\n      _line.end.z = 0; // get closest point on ray to segment\n\n      const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n      _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n      const zPos = THREE.MathUtils.lerp(_start4.z, _end4.z, param);\n      const isInClipSpace = zPos >= -1 && zPos <= 1;\n      const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\n\n      if (isInClipSpace && isInside) {\n        _line.start.fromBufferAttribute(instanceStart, i);\n\n        _line.end.fromBufferAttribute(instanceEnd, i);\n\n        _line.start.applyMatrix4(matrixWorld);\n\n        _line.end.applyMatrix4(matrixWorld);\n\n        const pointOnLine = new THREE.Vector3();\n        const point = new THREE.Vector3();\n        ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n        intersects.push({\n          point: point,\n          pointOnLine: pointOnLine,\n          distance: ray.origin.distanceTo(point),\n          object: this,\n          face: null,\n          faceIndex: i,\n          uv: null,\n          uv2: null\n        });\n      }\n    }\n  }\n\n}\n\nLineSegments2.prototype.LineSegments2 = true;\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super();\n    this.type = 'LineGeometry';\n  }\n\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n\n    super.setPositions(points);\n    return this;\n  }\n\n  setColors(array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n\n    super.setColors(colors);\n    return this;\n  }\n\n  fromLine(line) {\n    var geometry = line.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n}\n\nLineGeometry.prototype.isLineGeometry = true;\n\nclass Line2 extends LineSegments2 {\n  constructor() {\n    let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new LineGeometry();\n    let material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineMaterial({\n      color: Math.random() * 0xffffff\n    });\n    super(geometry, material);\n    this.type = 'Line2';\n  }\n\n}\n\nLine2.prototype.isLine2 = true;\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };","map":{"version":3,"names":["Box3","BufferGeometry","Float32BufferAttribute","InstancedBufferGeometry","InstancedInterleavedBuffer","InterleavedBufferAttribute","Sphere","Vector3","WireframeGeometry","ShaderLib","ShaderMaterial","UniformsLib","UniformsUtils","Vector2","Line3","MathUtils","Matrix4","Mesh","Vector4","THREE$2","window","THREE","setAttributeFn$1","setAttribute","_box$1","_vector","LineSegmentsGeometry","constructor","type","positions","uvs","index","setIndex","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","undefined","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","setColors","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","fromLineSegments","isGeometry","console","error","isBufferGeometry","setFromBufferAttribute","union","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","toJSON","applyMatrix","warn","prototype","isLineSegmentsGeometry","THREE$1","line","worldUnits","value","linewidth","resolution","dashScale","dashSize","dashOffset","gapSize","uniforms","merge","common","fog","vertexShader","fragmentShader","LineMaterial","parameters","clone","clipping","Object","defineProperties","color","enumerable","get","diffuse","set","defines","WORLD_UNITS","dashed","Boolean","USE_DASH","opacity","copy","alphaToCoverage","ALPHA_TO_COVERAGE","extensions","derivatives","setValues","isLineMaterial","setAttributeFn","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","LineSegments2","material","random","computeLineDistances","lineDistances","j","l","distanceTo","instanceDistanceBuffer","raycast","raycaster","intersects","camera","threshold","params","Line2","ray","projectionMatrix","matrixWorld","lineWidth","near","ssMaxWidth","width","height","distanceToSphere","distanceToPoint","origin","multiplyScalar","w","projectionMatrixInverse","sphereMargin","abs","intersectsSphere","distanceToBox","boxMargin","x","y","z","min","intersectsBox","at","matrixWorldInverse","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","distance","object","face","faceIndex","uv","uv2","LineGeometry","length","points","fromLine","isLineGeometry","isLine2"],"sources":["/Users/ludvigbergsaker/Documents/Notify/notify_custom/notify_custom/node_modules/three-fatline/dist/three-fatline.module.js"],"sourcesContent":["import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Vector2, Line3, MathUtils, Matrix4, Mesh, Vector4 } from 'three';\n\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n}; // support multiple method names for backwards threejs compatibility\n\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _box$1 = new THREE$2.Box3();\n\nconst _vector = new THREE$2.Vector3();\n\nclass LineSegmentsGeometry extends THREE$2.InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.type = 'LineSegmentsGeometry';\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this[setAttributeFn$1]('position', new THREE$2.Float32BufferAttribute(positions, 3));\n    this[setAttributeFn$1]('uv', new THREE$2.Float32BufferAttribute(uvs, 2));\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  setPositions(array) {\n    let lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    const instanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn$1]('instanceStart', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn$1]('instanceEnd', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n\n  setColors(array) {\n    let colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    const instanceColorBuffer = new THREE$2.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn$1]('instanceColorStart', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn$1]('instanceColorEnd', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new THREE$2.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new THREE$2.Box3();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start);\n\n      _box$1.setFromBufferAttribute(end);\n\n      this.boundingBox.union(_box$1);\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new THREE$2.Sphere();\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n\n        _vector.fromBufferAttribute(end, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n      }\n    }\n  }\n\n  toJSON() {// todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n}\n\nLineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  worldUnits: {\n    value: 1\n  },\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new THREE$1.Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  } // todo FIX - maybe change to totalSize\n\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\tworldStart = start.xyz;\n\t\t\tworldEnd = end.xyz;\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segements overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends THREE$1.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n      uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n      vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n      fragmentShader: THREE$1.ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      worldUnits: {\n        enumerable: true,\n        get: function () {\n          return 'WORLD_UNITS' in this.defines;\n        },\n        set: function (value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = '';\n          } else {\n            delete this.defines.WORLD_UNITS;\n          }\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n\n        set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value === true) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value === true) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nLineMaterial.prototype.isLineMaterial = true;\n\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4\n};\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _start = new THREE.Vector3();\n\nconst _end = new THREE.Vector3();\n\nconst _start4 = new THREE.Vector4();\n\nconst _end4 = new THREE.Vector4();\n\nconst _ssOrigin = new THREE.Vector4();\n\nconst _ssOrigin3 = new THREE.Vector3();\n\nconst _mvMatrix = new THREE.Matrix4();\n\nconst _line = new THREE.Line3();\n\nconst _closestPoint = new THREE.Vector3();\n\nconst _box = new THREE.Box3();\n\nconst _sphere = new THREE.Sphere();\n\nconst _clipToWorldVector = new THREE.Vector4();\n\nclass LineSegments2 extends THREE.Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'LineSegments2';\n  } // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry[setAttributeFn]('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry[setAttributeFn]('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    const ray = raycaster.ray;\n    const camera = raycaster.camera;\n    const projectionMatrix = camera.projectionMatrix;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    const resolution = material.resolution;\n    const lineWidth = material.linewidth + threshold;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n    const near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\n    // width in clip space\n\n    const ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\n    // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n\n    const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _sphere.radius += sphereMargin;\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) {\n      return;\n    } //\n    // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n\n    const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _box.max.x += boxMargin;\n    _box.max.y += boxMargin;\n    _box.max.z += boxMargin;\n    _box.min.x -= boxMargin;\n    _box.min.y -= boxMargin;\n    _box.min.z -= boxMargin;\n\n    if (raycaster.ray.intersectsBox(_box) === false) {\n      return;\n    } //\n    // pick a point 1 unit out along the ray to avoid the ray origin\n    // sitting at the camera origin which will cause \"w\" to be 0 when\n    // applying the projection matrix.\n\n\n    ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n    _ssOrigin.w = 1;\n\n    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n    _ssOrigin.applyMatrix4(projectionMatrix);\n\n    _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n    _ssOrigin.x *= resolution.x / 2;\n    _ssOrigin.y *= resolution.y / 2;\n    _ssOrigin.z = 0;\n\n    _ssOrigin3.copy(_ssOrigin);\n\n    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n    for (let i = 0, l = instanceStart.count; i < l; i++) {\n      _start4.fromBufferAttribute(instanceStart, i);\n\n      _end4.fromBufferAttribute(instanceEnd, i);\n\n      _start4.w = 1;\n      _end4.w = 1; // camera space\n\n      _start4.applyMatrix4(_mvMatrix);\n\n      _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n      var isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n      if (isBehindCameraNear) {\n        continue;\n      } // trim the segment if it extends behind camera near\n\n\n      if (_start4.z > near) {\n        const deltaDist = _start4.z - _end4.z;\n        const t = (_start4.z - near) / deltaDist;\n\n        _start4.lerp(_end4, t);\n      } else if (_end4.z > near) {\n        const deltaDist = _end4.z - _start4.z;\n        const t = (_end4.z - near) / deltaDist;\n\n        _end4.lerp(_start4, t);\n      } // clip space\n\n\n      _start4.applyMatrix4(projectionMatrix);\n\n      _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n      _start4.multiplyScalar(1 / _start4.w);\n\n      _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n      _start4.x *= resolution.x / 2;\n      _start4.y *= resolution.y / 2;\n      _end4.x *= resolution.x / 2;\n      _end4.y *= resolution.y / 2; // create 2d segment\n\n      _line.start.copy(_start4);\n\n      _line.start.z = 0;\n\n      _line.end.copy(_end4);\n\n      _line.end.z = 0; // get closest point on ray to segment\n\n      const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n      _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n      const zPos = THREE.MathUtils.lerp(_start4.z, _end4.z, param);\n      const isInClipSpace = zPos >= -1 && zPos <= 1;\n      const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\n\n      if (isInClipSpace && isInside) {\n        _line.start.fromBufferAttribute(instanceStart, i);\n\n        _line.end.fromBufferAttribute(instanceEnd, i);\n\n        _line.start.applyMatrix4(matrixWorld);\n\n        _line.end.applyMatrix4(matrixWorld);\n\n        const pointOnLine = new THREE.Vector3();\n        const point = new THREE.Vector3();\n        ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n        intersects.push({\n          point: point,\n          pointOnLine: pointOnLine,\n          distance: ray.origin.distanceTo(point),\n          object: this,\n          face: null,\n          faceIndex: i,\n          uv: null,\n          uv2: null\n        });\n      }\n    }\n  }\n\n}\n\nLineSegments2.prototype.LineSegments2 = true;\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super();\n    this.type = 'LineGeometry';\n  }\n\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n\n    super.setPositions(points);\n    return this;\n  }\n\n  setColors(array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n\n    super.setColors(colors);\n    return this;\n  }\n\n  fromLine(line) {\n    var geometry = line.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n}\n\nLineGeometry.prototype.isLineGeometry = true;\n\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'Line2';\n  }\n\n}\n\nLine2.prototype.isLine2 = true;\n\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };\n"],"mappings":"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ADa;EAIzBC,SAAS,EAAE;IACTD,KAAK,EAAE;EADE,CAJc;EAOzBE,UAAU,EAAE;IACVF,KAAK,EAAE,IAAIH,OAAO,CAAC1E,OAAZ,CAAoB,CAApB,EAAuB,CAAvB;EADG,CAPa;EAUzBgF,SAAS,EAAE;IACTH,KAAK,EAAE;EADE,CAVc;EAazBI,QAAQ,EAAE;IACRJ,KAAK,EAAE;EADC,CAbe;EAgBzBK,UAAU,EAAE;IACVL,KAAK,EAAE;EADG,CAhBa;EAmBzBM,OAAO,EAAE;IACPN,KAAK,EAAE;EADA,CAnBgB,CAqBvB;;AArBuB,CAA3B;AAwBAH,OAAO,CAAC9E,SAAR,CAAkB,MAAlB,IAA4B;EAC1BwF,QAAQ,EAAEV,OAAO,CAAC3E,aAAR,CAAsBsF,KAAtB,CAA4B,CAACX,OAAO,CAAC5E,WAAR,CAAoBwF,MAArB,EAA6BZ,OAAO,CAAC5E,WAAR,CAAoByF,GAAjD,EAAsDb,OAAO,CAAC5E,WAAR,CAAoB6E,IAA1E,CAA5B,CADgB;EAE1Ba,YAAY;EACZ;EACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GApN4B;EAqN1BC,cAAc;EACd;EACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzW4B,CAA5B;;AA4WA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"},"metadata":{},"sourceType":"module"}