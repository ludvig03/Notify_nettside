{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute } from 'three';\nimport { merge, extent, mean } from 'd3-array';\nimport earcut from 'earcut';\nimport Delaunator from 'delaunator';\nimport turfPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { geoBounds, geoContains, geoDistance, geoInterpolate } from 'd3-geo';\nimport { geoVoronoi } from 'd3-geo-voronoi';\nimport { scaleLinear } from 'd3-scale';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction geoPolygonTriangulate(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$resolution = _ref.resolution,\n      resolution = _ref$resolution === void 0 ? Infinity : _ref$resolution;\n\n  var contour = interpolateContourPoints(polygon, resolution);\n  var edgePoints = merge(contour);\n  var innerPoints = getInnerGeoPoints(polygon, resolution);\n  var points = [].concat(_toConsumableArray(edgePoints), _toConsumableArray(innerPoints));\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds = geoBounds(boundariesGeojson),\n      _geoBounds2 = _slicedToArray(_geoBounds, 2),\n      _geoBounds2$ = _slicedToArray(_geoBounds2[0], 2),\n      minLng = _geoBounds2$[0],\n      minLat = _geoBounds2$[1],\n      _geoBounds2$2 = _slicedToArray(_geoBounds2[1], 2),\n      maxLng = _geoBounds2$2[0],\n      maxLat = _geoBounds2$2[1];\n\n  var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian\n  || maxLat >= 89 // crosses north pole\n  || minLat <= -89; // crosses south pole\n\n  var indices = [];\n\n  if (crossesPoleOrAntimeridian) {\n    // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian\n    var vt = geoVoronoi(points).triangles(); // geoDelaunay generates more triangles than needed\n\n    var pntMap = new Map(points.map(function (_ref2, idx) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          lng = _ref3[0],\n          lat = _ref3[1];\n\n      return [\"\".concat(lng, \"-\").concat(lat), idx];\n    }));\n    vt.features.forEach(function (f) {\n      var _indices;\n\n      var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut\n\n      var inds = [];\n      triangle.forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            lng = _ref5[0],\n            lat = _ref5[1];\n\n        var k = \"\".concat(lng, \"-\").concat(lat);\n        pntMap.has(k) && inds.push(pntMap.get(k));\n      });\n      if (inds.length !== 3) return; // triangle malfunction\n      // exclude edge triangles outside polygon perimeter or through holes\n\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = f.properties.circumcenter;\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;\n      }\n\n      (_indices = indices).push.apply(_indices, inds);\n    });\n  } else if (!innerPoints.length) {\n    // earcut triangulation slightly more performing if it's only using the polygon perimeter\n    var _earcut$flatten = earcut.flatten(contour),\n        vertices = _earcut$flatten.vertices,\n        _earcut$flatten$holes = _earcut$flatten.holes,\n        holes = _earcut$flatten$holes === void 0 ? [] : _earcut$flatten$holes;\n\n    indices = earcut(vertices, holes, 2);\n  } else {\n    (function () {\n      // use delaunator\n      var delaunay = Delaunator.from(points);\n\n      var _loop = function _loop(i, len) {\n        var _indices2;\n\n        var inds = [2, 1, 0].map(function (idx) {\n          return delaunay.triangles[i + idx];\n        }); // reverse wound to have same orientation as earcut\n\n        var triangle = inds.map(function (indice) {\n          return points[indice];\n        }); // exclude edge triangles outside polygon perimeter or through holes\n\n        if (inds.some(function (ind) {\n          return ind < edgePoints.length;\n        })) {\n          var triangleCentroid = [0, 1].map(function (coordIdx) {\n            return mean(triangle, function (p) {\n              return p[coordIdx];\n            });\n          });\n          if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return \"continue\";\n        }\n\n        (_indices2 = indices).push.apply(_indices2, _toConsumableArray(inds));\n      };\n\n      for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      }\n    })();\n  } // calc uvs\n\n\n  var lngUvScale = scaleLinear(extent(points, function (d) {\n    return d[0];\n  }), [0, 1]);\n  var latUvScale = scaleLinear(extent(points, function (d) {\n    return d[1];\n  }), [0, 1]);\n  var uvs = points.map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n        lng = _ref7[0],\n        lat = _ref7[1];\n\n    return [lngUvScale(lng), latUvScale(lat)];\n  });\n  var triangles = {\n    points: points,\n    indices: indices,\n    uvs: uvs\n  };\n  return {\n    contour: contour,\n    triangles: triangles\n  };\n}\n\nfunction interpolateContourPoints(polygon, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygon.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n\n        if (dist > maxDistance) {\n          var interpol = geoInterpolate(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\n\nfunction getInnerGeoPoints(polygon, maxDistance) {\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds3 = geoBounds(boundariesGeojson),\n      _geoBounds4 = _slicedToArray(_geoBounds3, 2),\n      _geoBounds4$ = _slicedToArray(_geoBounds4[0], 2),\n      minLng = _geoBounds4$[0],\n      minLat = _geoBounds4$[1],\n      _geoBounds4$2 = _slicedToArray(_geoBounds4[1], 2),\n      maxLng = _geoBounds4$2[0],\n      maxLat = _geoBounds4$2[1]; // polygon smaller than maxDistance -> no inner points\n\n\n  if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];\n  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;\n  return getGeoSpiralGrid(maxDistance, {\n    minLng: minLng,\n    maxLng: maxLng,\n    minLat: minLat,\n    maxLat: maxLat\n  }).filter(function (pnt) {\n    return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);\n  });\n}\n\nfunction getGeoSpiralGrid(distanceBetweenPoints) {\n  var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      minLng = _ref8.minLng,\n      maxLng = _ref8.maxLng,\n      minLat = _ref8.minLat,\n      maxLat = _ref8.maxLat;\n\n  var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI); // https://observablehq.com/@mbostock/spherical-fibonacci-lattice\n\n  var phi = (1 + Math.sqrt(5)) / 2; // golden ratio\n\n  var getPntLng = function getPntLng(idx) {\n    return idx / phi * 360 % 360 - 180;\n  };\n\n  var getPntLat = function getPntLat(idx) {\n    return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;\n  };\n\n  var getPntIdx = function getPntIdx(lat) {\n    return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;\n  };\n\n  var pntIdxRange = [maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1];\n  var isLngInRange = minLng === undefined && maxLng === undefined ? function () {\n    return true;\n  } : minLng === undefined ? function (lng) {\n    return lng <= maxLng;\n  } : maxLng === undefined ? function (lng) {\n    return lng >= minLng;\n  } : maxLng >= minLng ? function (lng) {\n    return lng >= minLng && lng <= maxLng;\n  } : function (lng) {\n    return lng >= minLng || lng <= maxLng;\n  }; // for ranges that cross the anti-meridian\n\n  var pnts = [];\n\n  for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {\n    var lng = getPntLng(i);\n    isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);\n  }\n\n  return pnts;\n}\n\nfunction pointInside(pnt, polygon) {\n  var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)\n\n  return crossesPoleOrAntimeridian ? geoContains(polygon, pnt) : turfPointInPolygon(pnt, polygon);\n}\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute\n};\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar ConicPolygonBufferGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  _inherits(ConicPolygonBufferGeometry, _THREE$BufferGeometry);\n\n  var _super = _createSuper(ConicPolygonBufferGeometry);\n\n  function ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n    var _this;\n\n    _classCallCheck(this, ConicPolygonBufferGeometry);\n\n    _this = _super.call(this);\n    _this.type = 'ConicPolygonBufferGeometry';\n    _this.parameters = {\n      polygonGeoJson: polygonGeoJson,\n      startHeight: startHeight,\n      endHeight: endHeight,\n      closedBottom: closedBottom,\n      closedTop: closedTop,\n      includeSides: includeSides,\n      curvatureResolution: curvatureResolution\n    }; // defaults\n\n    startHeight = startHeight || 0;\n    endHeight = endHeight || 1;\n    closedBottom = closedBottom !== undefined ? closedBottom : true;\n    closedTop = closedTop !== undefined ? closedTop : true;\n    includeSides = includeSides !== undefined ? includeSides : true;\n    curvatureResolution = curvatureResolution || 5; // in angular degrees\n    // pre-calculate contour, triangulation and UV maps\n\n    var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {\n      resolution: curvatureResolution\n    }),\n        contour = _geoPolygonTriangulat.contour,\n        triangles = _geoPolygonTriangulat.triangles;\n\n    var flatUvs = merge(triangles.uvs);\n    var vertices = [];\n    var uvs = [];\n    var indices = [];\n    var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n    var addGroup = function addGroup(groupData) {\n      var prevVertCnt = Math.round(vertices.length / 3);\n      var prevIndCnt = indices.length;\n      vertices = vertices.concat(groupData.vertices);\n      uvs = uvs.concat(groupData.uvs);\n      indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n        return ind + prevVertCnt;\n      }));\n\n      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n    };\n\n    includeSides && addGroup(generateTorso());\n    closedBottom && addGroup(generateCap(startHeight, false));\n    closedTop && addGroup(generateCap(endHeight, true)); // build geometry\n\n    _this.setIndex(indices);\n\n    _this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n    _this[setAttributeFn]('uv', new THREE.Float32BufferAttribute(uvs, 2)); // auto-calculate normals\n\n\n    _this.computeVertexNormals(); //\n\n\n    function generateVertices(polygon, altitude) {\n      var coords3d = polygon.map(function (coords) {\n        return coords.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              lng = _ref2[0],\n              lat = _ref2[1];\n\n          return polar2Cartesian(lat, lng, altitude);\n        });\n      }); // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n\n      return earcut.flatten(coords3d);\n    }\n\n    function generateTorso() {\n      var _generateVertices = generateVertices(contour, startHeight),\n          bottomVerts = _generateVertices.vertices,\n          holes = _generateVertices.holes;\n\n      var _generateVertices2 = generateVertices(contour, endHeight),\n          topVerts = _generateVertices2.vertices;\n\n      var vertices = merge([topVerts, bottomVerts]);\n      var numPoints = Math.round(topVerts.length / 3);\n      var holesIdx = new Set(holes);\n      var lastHoleIdx = 0;\n      var indices = [];\n\n      for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n        var v1Idx = v0Idx + 1; // next point\n\n        if (v1Idx === numPoints) {\n          v1Idx = lastHoleIdx; // close final loop\n        } else if (holesIdx.has(v1Idx)) {\n          var holeIdx = v1Idx;\n          v1Idx = lastHoleIdx; // close hole loop\n\n          lastHoleIdx = holeIdx;\n        } // Each pair of coords generates two triangles (faces)\n\n\n        indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n        indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n      }\n\n      var uvs = []; // wrap texture around perimeter (u), with v=1 on top\n\n      for (var v = 1; v >= 0; v--) {\n        for (var i = 0; i < numPoints; i += 1) {\n          uvs.push(i / (numPoints - 1), v);\n        }\n      }\n\n      return {\n        indices: indices,\n        vertices: vertices,\n        uvs: uvs\n      };\n    }\n\n    function generateCap(radius) {\n      var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return {\n        // need to reverse-wind the bottom triangles to make them face outwards\n        indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),\n        vertices: generateVertices([triangles.points], radius).vertices,\n        uvs: flatUvs\n      };\n    }\n\n    return _this;\n  }\n\n  return _createClass(ConicPolygonBufferGeometry);\n}(THREE.BufferGeometry); //\n\n\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta), // x\n  r * Math.cos(phi), // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nexport { ConicPolygonBufferGeometry, ConicPolygonBufferGeometry as ConicPolygonGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","merge","extent","mean","earcut","Delaunator","turfPointInPolygon","geoBounds","geoContains","geoDistance","geoInterpolate","geoVoronoi","scaleLinear","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_inherits","subClass","superClass","create","constructor","value","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","call","e","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","_createSuper","Derived","hasNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","arguments","apply","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","Symbol","iterator","from","_i","_arr","_n","_d","_s","_e","next","done","push","err","minLen","n","toString","slice","name","test","len","arr2","geoPolygonTriangulate","polygon","_ref","undefined","_ref$resolution","resolution","Infinity","contour","interpolateContourPoints","edgePoints","innerPoints","getInnerGeoPoints","points","concat","boundariesGeojson","type","coordinates","_geoBounds","_geoBounds2","_geoBounds2$","minLng","minLat","_geoBounds2$2","maxLng","maxLat","crossesPoleOrAntimeridian","indices","vt","triangles","pntMap","Map","map","_ref2","idx","_ref3","lng","lat","features","forEach","f","_indices","triangle","geometry","reverse","inds","_ref4","_ref5","k","has","get","some","ind","triangleCentroid","properties","circumcenter","pointInside","_earcut$flatten","flatten","vertices","_earcut$flatten$holes","holes","delaunay","_loop","_indices2","indice","coordIdx","_ret","lngUvScale","d","latUvScale","uvs","_ref6","_ref7","maxDistance","coords","pnts","prevPnt","pnt","dist","Math","PI","interpol","tStep","ceil","t","_geoBounds3","_geoBounds4","_geoBounds4$","_geoBounds4$2","min","abs","getGeoSpiralGrid","filter","distanceBetweenPoints","_ref8","numPoints","round","pow","phi","sqrt","getPntLng","getPntLat","acos","getPntIdx","cos","pntIdxRange","floor","isLngInRange","THREE","window","setAttributeFn","setAttribute","ConicPolygonBufferGeometry","_THREE$BufferGeometry","_super","polygonGeoJson","startHeight","endHeight","closedBottom","closedTop","includeSides","curvatureResolution","_this","parameters","_geoPolygonTriangulat","flatUvs","groupCnt","addGroup","groupData","prevVertCnt","prevIndCnt","generateTorso","generateCap","setIndex","computeVertexNormals","generateVertices","altitude","coords3d","polar2Cartesian","_generateVertices","bottomVerts","_generateVertices2","topVerts","holesIdx","Set","lastHoleIdx","v0Idx","v1Idx","holeIdx","v","radius","isTop","r","theta","sin","ConicPolygonGeometry"],"sources":["/Users/ludvigbergsaker/Documents/Notify/notify_custom/notify_custom/node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.module.js"],"sourcesContent":["import { BufferGeometry, Float32BufferAttribute } from 'three';\nimport { merge, extent, mean } from 'd3-array';\nimport earcut from 'earcut';\nimport Delaunator from 'delaunator';\nimport turfPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { geoBounds, geoContains, geoDistance, geoInterpolate } from 'd3-geo';\nimport { geoVoronoi } from 'd3-geo-voronoi';\nimport { scaleLinear } from 'd3-scale';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction geoPolygonTriangulate(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$resolution = _ref.resolution,\n      resolution = _ref$resolution === void 0 ? Infinity : _ref$resolution;\n\n  var contour = interpolateContourPoints(polygon, resolution);\n  var edgePoints = merge(contour);\n  var innerPoints = getInnerGeoPoints(polygon, resolution);\n  var points = [].concat(_toConsumableArray(edgePoints), _toConsumableArray(innerPoints));\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds = geoBounds(boundariesGeojson),\n      _geoBounds2 = _slicedToArray(_geoBounds, 2),\n      _geoBounds2$ = _slicedToArray(_geoBounds2[0], 2),\n      minLng = _geoBounds2$[0],\n      minLat = _geoBounds2$[1],\n      _geoBounds2$2 = _slicedToArray(_geoBounds2[1], 2),\n      maxLng = _geoBounds2$2[0],\n      maxLat = _geoBounds2$2[1];\n\n  var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian\n  || maxLat >= 89 // crosses north pole\n  || minLat <= -89; // crosses south pole\n\n  var indices = [];\n\n  if (crossesPoleOrAntimeridian) {\n    // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian\n    var vt = geoVoronoi(points).triangles(); // geoDelaunay generates more triangles than needed\n\n    var pntMap = new Map(points.map(function (_ref2, idx) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          lng = _ref3[0],\n          lat = _ref3[1];\n\n      return [\"\".concat(lng, \"-\").concat(lat), idx];\n    }));\n    vt.features.forEach(function (f) {\n      var _indices;\n\n      var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut\n\n      var inds = [];\n      triangle.forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            lng = _ref5[0],\n            lat = _ref5[1];\n\n        var k = \"\".concat(lng, \"-\").concat(lat);\n        pntMap.has(k) && inds.push(pntMap.get(k));\n      });\n      if (inds.length !== 3) return; // triangle malfunction\n      // exclude edge triangles outside polygon perimeter or through holes\n\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = f.properties.circumcenter;\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;\n      }\n\n      (_indices = indices).push.apply(_indices, inds);\n    });\n  } else if (!innerPoints.length) {\n    // earcut triangulation slightly more performing if it's only using the polygon perimeter\n    var _earcut$flatten = earcut.flatten(contour),\n        vertices = _earcut$flatten.vertices,\n        _earcut$flatten$holes = _earcut$flatten.holes,\n        holes = _earcut$flatten$holes === void 0 ? [] : _earcut$flatten$holes;\n\n    indices = earcut(vertices, holes, 2);\n  } else {\n    (function () {\n      // use delaunator\n      var delaunay = Delaunator.from(points);\n\n      var _loop = function _loop(i, len) {\n        var _indices2;\n\n        var inds = [2, 1, 0].map(function (idx) {\n          return delaunay.triangles[i + idx];\n        }); // reverse wound to have same orientation as earcut\n\n        var triangle = inds.map(function (indice) {\n          return points[indice];\n        }); // exclude edge triangles outside polygon perimeter or through holes\n\n        if (inds.some(function (ind) {\n          return ind < edgePoints.length;\n        })) {\n          var triangleCentroid = [0, 1].map(function (coordIdx) {\n            return mean(triangle, function (p) {\n              return p[coordIdx];\n            });\n          });\n          if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return \"continue\";\n        }\n\n        (_indices2 = indices).push.apply(_indices2, _toConsumableArray(inds));\n      };\n\n      for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      }\n    })();\n  } // calc uvs\n\n\n  var lngUvScale = scaleLinear(extent(points, function (d) {\n    return d[0];\n  }), [0, 1]);\n  var latUvScale = scaleLinear(extent(points, function (d) {\n    return d[1];\n  }), [0, 1]);\n  var uvs = points.map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n        lng = _ref7[0],\n        lat = _ref7[1];\n\n    return [lngUvScale(lng), latUvScale(lat)];\n  });\n  var triangles = {\n    points: points,\n    indices: indices,\n    uvs: uvs\n  };\n  return {\n    contour: contour,\n    triangles: triangles\n  };\n}\n\nfunction interpolateContourPoints(polygon, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygon.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n\n        if (dist > maxDistance) {\n          var interpol = geoInterpolate(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\n\nfunction getInnerGeoPoints(polygon, maxDistance) {\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds3 = geoBounds(boundariesGeojson),\n      _geoBounds4 = _slicedToArray(_geoBounds3, 2),\n      _geoBounds4$ = _slicedToArray(_geoBounds4[0], 2),\n      minLng = _geoBounds4$[0],\n      minLat = _geoBounds4$[1],\n      _geoBounds4$2 = _slicedToArray(_geoBounds4[1], 2),\n      maxLng = _geoBounds4$2[0],\n      maxLat = _geoBounds4$2[1]; // polygon smaller than maxDistance -> no inner points\n\n\n  if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];\n  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;\n  return getGeoSpiralGrid(maxDistance, {\n    minLng: minLng,\n    maxLng: maxLng,\n    minLat: minLat,\n    maxLat: maxLat\n  }).filter(function (pnt) {\n    return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);\n  });\n}\n\nfunction getGeoSpiralGrid(distanceBetweenPoints) {\n  var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      minLng = _ref8.minLng,\n      maxLng = _ref8.maxLng,\n      minLat = _ref8.minLat,\n      maxLat = _ref8.maxLat;\n\n  var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI); // https://observablehq.com/@mbostock/spherical-fibonacci-lattice\n\n  var phi = (1 + Math.sqrt(5)) / 2; // golden ratio\n\n  var getPntLng = function getPntLng(idx) {\n    return idx / phi * 360 % 360 - 180;\n  };\n\n  var getPntLat = function getPntLat(idx) {\n    return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;\n  };\n\n  var getPntIdx = function getPntIdx(lat) {\n    return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;\n  };\n\n  var pntIdxRange = [maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1];\n  var isLngInRange = minLng === undefined && maxLng === undefined ? function () {\n    return true;\n  } : minLng === undefined ? function (lng) {\n    return lng <= maxLng;\n  } : maxLng === undefined ? function (lng) {\n    return lng >= minLng;\n  } : maxLng >= minLng ? function (lng) {\n    return lng >= minLng && lng <= maxLng;\n  } : function (lng) {\n    return lng >= minLng || lng <= maxLng;\n  }; // for ranges that cross the anti-meridian\n\n  var pnts = [];\n\n  for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {\n    var lng = getPntLng(i);\n    isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);\n  }\n\n  return pnts;\n}\n\nfunction pointInside(pnt, polygon) {\n  var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)\n  return crossesPoleOrAntimeridian ? geoContains(polygon, pnt) : turfPointInPolygon(pnt, polygon);\n}\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute\n};\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar ConicPolygonBufferGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  _inherits(ConicPolygonBufferGeometry, _THREE$BufferGeometry);\n\n  var _super = _createSuper(ConicPolygonBufferGeometry);\n\n  function ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n    var _this;\n\n    _classCallCheck(this, ConicPolygonBufferGeometry);\n\n    _this = _super.call(this);\n    _this.type = 'ConicPolygonBufferGeometry';\n    _this.parameters = {\n      polygonGeoJson: polygonGeoJson,\n      startHeight: startHeight,\n      endHeight: endHeight,\n      closedBottom: closedBottom,\n      closedTop: closedTop,\n      includeSides: includeSides,\n      curvatureResolution: curvatureResolution\n    }; // defaults\n\n    startHeight = startHeight || 0;\n    endHeight = endHeight || 1;\n    closedBottom = closedBottom !== undefined ? closedBottom : true;\n    closedTop = closedTop !== undefined ? closedTop : true;\n    includeSides = includeSides !== undefined ? includeSides : true;\n    curvatureResolution = curvatureResolution || 5; // in angular degrees\n    // pre-calculate contour, triangulation and UV maps\n\n    var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {\n      resolution: curvatureResolution\n    }),\n        contour = _geoPolygonTriangulat.contour,\n        triangles = _geoPolygonTriangulat.triangles;\n\n    var flatUvs = merge(triangles.uvs);\n    var vertices = [];\n    var uvs = [];\n    var indices = [];\n    var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n    var addGroup = function addGroup(groupData) {\n      var prevVertCnt = Math.round(vertices.length / 3);\n      var prevIndCnt = indices.length;\n      vertices = vertices.concat(groupData.vertices);\n      uvs = uvs.concat(groupData.uvs);\n      indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n        return ind + prevVertCnt;\n      }));\n\n      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n    };\n\n    includeSides && addGroup(generateTorso());\n    closedBottom && addGroup(generateCap(startHeight, false));\n    closedTop && addGroup(generateCap(endHeight, true)); // build geometry\n\n    _this.setIndex(indices);\n\n    _this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n    _this[setAttributeFn]('uv', new THREE.Float32BufferAttribute(uvs, 2)); // auto-calculate normals\n\n\n    _this.computeVertexNormals(); //\n\n\n    function generateVertices(polygon, altitude) {\n      var coords3d = polygon.map(function (coords) {\n        return coords.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              lng = _ref2[0],\n              lat = _ref2[1];\n\n          return polar2Cartesian(lat, lng, altitude);\n        });\n      }); // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n\n      return earcut.flatten(coords3d);\n    }\n\n    function generateTorso() {\n      var _generateVertices = generateVertices(contour, startHeight),\n          bottomVerts = _generateVertices.vertices,\n          holes = _generateVertices.holes;\n\n      var _generateVertices2 = generateVertices(contour, endHeight),\n          topVerts = _generateVertices2.vertices;\n\n      var vertices = merge([topVerts, bottomVerts]);\n      var numPoints = Math.round(topVerts.length / 3);\n      var holesIdx = new Set(holes);\n      var lastHoleIdx = 0;\n      var indices = [];\n\n      for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n        var v1Idx = v0Idx + 1; // next point\n\n        if (v1Idx === numPoints) {\n          v1Idx = lastHoleIdx; // close final loop\n        } else if (holesIdx.has(v1Idx)) {\n          var holeIdx = v1Idx;\n          v1Idx = lastHoleIdx; // close hole loop\n\n          lastHoleIdx = holeIdx;\n        } // Each pair of coords generates two triangles (faces)\n\n\n        indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n        indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n      }\n\n      var uvs = []; // wrap texture around perimeter (u), with v=1 on top\n\n      for (var v = 1; v >= 0; v--) {\n        for (var i = 0; i < numPoints; i += 1) {\n          uvs.push(i / (numPoints - 1), v);\n        }\n      }\n\n      return {\n        indices: indices,\n        vertices: vertices,\n        uvs: uvs\n      };\n    }\n\n    function generateCap(radius) {\n      var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return {\n        // need to reverse-wind the bottom triangles to make them face outwards\n        indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),\n        vertices: generateVertices([triangles.points], radius).vertices,\n        uvs: flatUvs\n      };\n    }\n\n    return _this;\n  }\n\n  return _createClass(ConicPolygonBufferGeometry);\n}(THREE.BufferGeometry); //\n\n\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta), // x\n  r * Math.cos(phi), // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nexport { ConicPolygonBufferGeometry, ConicPolygonBufferGeometry as ConicPolygonGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}