{"ast":null,"code":"import { Delaunay } from \"d3-delaunay\";\nimport { scaleLinear } from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\nexport default function () {\n  // accessors\n  let x = d => d[0],\n      y = d => d[1],\n      value = d => isFinite(+d[2]) ? +d[2] : 0,\n      triangulate = Delaunay.from,\n      pointInterpolate = (i, j, a) => {\n    const {\n      points\n    } = triangulation;\n    const A = [points[2 * i], points[2 * i + 1]],\n          B = [points[2 * j], points[2 * j + 1]];\n    return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n  },\n      ringsort = planarRingsort;\n\n  let thresholds, values, triangulation;\n\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear().domain(extent(values)).nice().ticks(thresholds);\n    }\n  }\n\n  function* tricontours(points) {\n    init(points);\n\n    for (const threshold of thresholds) {\n      const polygon = tricontour(triangulation, values, threshold);\n      yield {\n        type: \"MultiPolygon\",\n        coordinates: polygon,\n        value: threshold\n      };\n    }\n  }\n\n  function contour(points, threshold) {\n    init(points);\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n\n  function* isobands(points) {\n    init(points);\n    let p0, p1, th0;\n\n    for (const th of thresholds) {\n      if (p1) p0 = p1;\n      p1 = merge(tricontour(triangulation, values, th));\n\n      if (p0) {\n        yield {\n          type: \"MultiPolygon\",\n          coordinates: ringsort(p0.concat(p1.map(ring => ring.slice().reverse()))),\n          value: th0,\n          valueMax: th\n        };\n      }\n\n      th0 = th;\n    }\n  }\n\n  const contours = function (data) {\n    return [...tricontours(data)];\n  }; // API\n\n\n  contours.x = _ => _ ? (x = _, contours) : x;\n\n  contours.y = _ => _ ? (y = _, contours) : y;\n\n  contours.value = _ => _ ? (value = _, contours) : value;\n\n  contours.thresholds = _ => _ ? (thresholds = _, contours) : thresholds;\n\n  contours.triangulate = _ => _ ? (triangulate = _, contours) : triangulate;\n\n  contours.pointInterpolate = _ => _ ? (pointInterpolate = _, contours) : pointInterpolate;\n\n  contours.ringsort = _ => _ ? (ringsort = _, contours) : ringsort;\n\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands; // expose the internals (useful for debugging, not part of the API)\n\n  contours._values = () => values;\n\n  contours._triangulation = () => triangulation;\n\n  return contours; // navigate a triangle\n\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n\n  function tricontour(triangulation, values) {\n    let v0 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    // sanity check\n    for (const d of values) if (!isFinite(d)) throw [\"Invalid value\", d];\n\n    const {\n      halfedges,\n      hull,\n      inedges,\n      triangles\n    } = triangulation,\n          n = values.length;\n\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n\n    function alpha(i, j) {\n      const u = values[i],\n            v = values[j];\n\n      if (u <= v0 && v >= v0 && u < v) {\n        return (v0 - u) / (v - u);\n      }\n    } // create the path from the first exit; cancel visited halfedges\n\n\n    const rings = [],\n          visited = new Uint8Array(halfedges.length).fill(0);\n    let path, i, j, k, a;\n\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n      i = k;\n      path = [];\n\n      while ((a = edgealpha(i)) > 0) {\n        const [ti, tj] = [triangles[i], triangles[j = next(i)]]; // is our tour done?\n\n        if (path.length && ti === path[0].ti && tj === path[0].tj || path.length > 2 * n) break;\n        visited[i] = 1;\n        path.push({\n          ti,\n          tj,\n          a\n        }); // jump into the adjacent triangle\n\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          }\n\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          } // debugger;\n\n        } // or follow the hull\n        else {\n          let h = (hull.indexOf(triangles[i]) + 1) % hull.length;\n\n          while (values[hull[h]] < v0) {\n            // debugger;\n            h = (h + 1) % hull.length;\n          }\n\n          while (values[hull[h]] >= v0) {\n            path.push({\n              ti: hull[h],\n              tj: hull[h],\n              a: 0\n            });\n            h = (h + 1) % hull.length;\n          } // take that entry\n\n\n          j = inedges[hull[h]];\n          path.push({\n            ti: hull[h],\n            tj: triangles[j],\n            a: alpha(hull[h], triangles[j])\n          });\n          if (edgealpha(i = next(j)) > 0) continue;\n          if (edgealpha(i = prev(j)) > 0) continue;\n        }\n      }\n\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(_ref => {\n          let {\n            ti,\n            tj,\n            a\n          } = _ref;\n          return pointInterpolate(ti, tj, a);\n        }));\n      }\n    } // special case all values on the hull are >=v0, add the hull\n\n\n    if (hull.every(d => values[d] >= v0)) {\n      rings.unshift(Array.from(hull).concat([hull[0]]).map(i => pointInterpolate(i, i, 0)));\n    }\n\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}","map":{"version":3,"names":["Delaunay","scaleLinear","extent","merge","planarRingsort","x","d","y","value","isFinite","triangulate","from","pointInterpolate","i","j","a","points","triangulation","A","B","ringsort","thresholds","values","init","Array","domain","nice","ticks","tricontours","threshold","polygon","tricontour","type","coordinates","contour","isobands","p0","p1","th0","th","concat","map","ring","slice","reverse","valueMax","contours","data","_","_values","_triangulation","next","prev","v0","halfedges","hull","inedges","triangles","n","length","edgealpha","alpha","u","v","rings","visited","Uint8Array","fill","path","k","ti","tj","push","h","indexOf","every","unshift"],"sources":["/Users/ludvigbergsaker/Documents/Notify/notify_custom/notify_custom/node_modules/d3-tricontour/src/tricontour.js"],"sourcesContent":["import {Delaunay} from \"d3-delaunay\";\nimport {scaleLinear} from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\n\nexport default function() {\n  // accessors\n  let x = d => d[0],\n    y = d => d[1],\n    value = d => (isFinite(+d[2]) ? +d[2] : 0),\n    triangulate = Delaunay.from,\n    pointInterpolate = (i, j, a) => {\n      const { points } = triangulation;\n      const A = [points[2 * i], points[2 * i + 1]],\n        B = [points[2 * j], points[2 * j + 1]];\n      return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n    },\n    ringsort = planarRingsort;\n\n  let thresholds, values, triangulation;\n\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear()\n        .domain(extent(values))\n        .nice()\n        .ticks(thresholds);\n    }\n  }\n\n  function* tricontours(points) {\n    init(points);\n\n    for (const threshold of thresholds) {\n      const polygon = tricontour(triangulation, values, threshold);\n      yield {\n        type: \"MultiPolygon\",\n        coordinates: polygon,\n        value: threshold\n      };\n    }\n  }\n\n  function contour(points, threshold) {\n    init(points);\n\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n\n  function* isobands(points) {\n    init(points);\n\n    let p0, p1, th0;\n    for (const th of thresholds) {\n      if (p1) p0 = p1;\n      p1 = merge(tricontour(triangulation, values, th));\n      if (p0) {\n        yield {\n          type: \"MultiPolygon\",\n          coordinates: ringsort(\n            p0.concat(p1.map(ring => ring.slice().reverse()))\n          ),\n          value: th0,\n          valueMax: th\n        };\n      }\n      th0 = th;\n    }\n  }\n\n  const contours = function(data) {\n    return [...tricontours(data)];\n  };\n\n  // API\n  contours.x = _ => (_ ? ((x = _), contours) : x);\n  contours.y = _ => (_ ? ((y = _), contours) : y);\n  contours.value = _ => (_ ? ((value = _), contours) : value);\n  contours.thresholds = _ => (_ ? ((thresholds = _), contours) : thresholds);\n  contours.triangulate = _ => (_ ? ((triangulate = _), contours) : triangulate);\n  contours.pointInterpolate = _ =>\n    _ ? ((pointInterpolate = _), contours) : pointInterpolate;\n  contours.ringsort = _ =>\n    _ ? ((ringsort = _), contours) : ringsort;\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands;\n\n  // expose the internals (useful for debugging, not part of the API)\n  contours._values = () => values;\n  contours._triangulation = () => triangulation;\n\n  return contours;\n\n  // navigate a triangle\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n\n  function tricontour(triangulation, values, v0 = 0) {\n    // sanity check\n    for (const d of values) if (!isFinite(d)) throw [\"Invalid value\", d];\n\n    const { halfedges, hull, inedges, triangles } = triangulation,\n      n = values.length;\n\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n    function alpha(i, j) {\n      const u = values[i],\n        v = values[j];\n      if (u <= v0 && v >= v0 && u < v) {\n        return (v0 - u) / (v - u);\n      }\n    }\n\n    // create the path from the first exit; cancel visited halfedges\n    const rings = [],\n      visited = new Uint8Array(halfedges.length).fill(0);\n    let path, i, j, k, a;\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n\n      i = k;\n      path = [];\n\n      while ((a = edgealpha(i)) > 0) {\n        const [ti, tj] = [triangles[i], triangles[(j = next(i))]];\n\n        // is our tour done?\n        if (\n          (path.length && (ti === path[0].ti && tj === path[0].tj)) ||\n          path.length > 2 * n\n        )\n          break;\n\n        visited[i] = 1;\n        path.push({ ti, tj, a });\n\n        // jump into the adjacent triangle\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          // debugger;\n        }\n\n        // or follow the hull\n        else {\n          let h = (hull.indexOf(triangles[i]) + 1) % hull.length;\n\n          while (values[hull[h]] < v0) {\n            // debugger;\n            h = (h + 1) % hull.length;\n          }\n\n          while (values[hull[h]] >= v0) {\n            path.push({ ti: hull[h], tj: hull[h], a: 0 });\n            h = (h + 1) % hull.length;\n          }\n\n          // take that entry\n          j = inedges[hull[h]];\n          path.push({\n            ti: hull[h],\n            tj: triangles[j],\n            a: alpha(hull[h], triangles[j])\n          });\n\n          if (edgealpha((i = next(j))) > 0) continue;\n          if (edgealpha((i = prev(j))) > 0) continue;\n        }\n      }\n\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(({ ti, tj, a }) => pointInterpolate(ti, tj, a)));\n      }\n    }\n\n    // special case all values on the hull are >=v0, add the hull\n    if (hull.every(d => values[d] >= v0)) {\n      rings.unshift(\n        Array.from(hull)\n          .concat([hull[0]])\n          .map(i => pointInterpolate(i, i, 0))\n      );\n    }\n\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}